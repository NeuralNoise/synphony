// Generated by CoffeeScript 1.3.1

/*
SynPhony: Synthetic Phonics tool for early grade literacy teaching
Copyright (C) 2012  Ryan J. Sanche and Norbert Rennert

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


(function() {
  var DEBRIS, GPC, GPCState, GPCStates, GPCs, Grapheme, Graphemes, HYPHEN_APOSTROPHE, NamedCollection, NamedModel, Phoneme, Phonemes, Segmenter, Sentence, Sentences, Sequence, SequenceElement, SequenceElements, Sequences, Store, WHITESPACE, Word, Wordlist, Words, hasUpperCase,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  NamedModel = (function(_super) {

    __extends(NamedModel, _super);

    NamedModel.name = 'NamedModel';

    function NamedModel(attributes, options) {
      if (options == null) {
        options = {};
      }
      this.collection = options.collection;
      NamedModel.__super__.constructor.call(this, attributes, options);
    }

    NamedModel.prototype.validate = function(attribs) {
      var modelsWithMyName;
      if (!(attribs.name != null)) {
        return "Must have a name";
      } else if (this.collection != null) {
        modelsWithMyName = this.collection.where({
          name: attribs.name
        });
        if (_.isEmpty(modelsWithMyName)) {
          return null;
        } else if (modelsWithMyName.length > 1 || (_.first(modelsWithMyName)) !== this) {
          return "Model with name " + attribs.name + " already exists";
        }
      } else {
        return null;
      }
    };

    NamedModel.prototype.parseIdLookup = function(collectionName, fieldName, data) {
      var item,
        _this = this;
      if ((this.collection != null) && (this.collection[collectionName] != null)) {
        if (data[fieldName] instanceof Array && typeof (_.first(data[fieldName])) === "number") {
          return data[fieldName] = _.map(data[fieldName], function(id) {
            var item;
            item = _this.collection[collectionName].get(id);
            return item != null ? item : id;
          });
        } else if (typeof data[fieldName] === "number") {
          item = this.collection[collectionName].get(data[fieldName]);
          return data[fieldName] = item != null ? item : data[fieldName];
        }
      }
    };

    return NamedModel;

  })(Backbone.Model);

  NamedCollection = (function(_super) {

    __extends(NamedCollection, _super);

    NamedCollection.name = 'NamedCollection';

    function NamedCollection() {
      return NamedCollection.__super__.constructor.apply(this, arguments);
    }

    NamedCollection.prototype.getByName = function(name) {
      var model, _i, _len, _ref, _ref1;
      if (!(this._byName != null)) {
        this._byName = {};
        _ref = this.models;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          model = _ref[_i];
          if (((_ref1 = model.attributes) != null ? _ref1.name : void 0) != null) {
            this._byName[model.attributes.name] = model;
          }
        }
      }
      return this._byName[name] || null;
    };

    NamedCollection.prototype.add = function(models, options) {
      this._byName = null;
      return NamedCollection.__super__.add.call(this, models, options);
    };

    NamedCollection.prototype.remove = function(models, options) {
      this._byName = null;
      return NamedCollection.__super__.remove.call(this, models, options);
    };

    return NamedCollection;

  })(Backbone.Collection);

  Store = (function() {

    Store.name = 'Store';

    Store.prototype.phonemes = null;

    Store.prototype.graphemes = null;

    Store.prototype.gpcs = null;

    Store.prototype.words = null;

    Store.prototype.sentences = null;

    Store.prototype.sequences = null;

    function Store() {
      this.phonemes = new Phonemes;
      this.graphemes = new Graphemes;
      this.gpcs = new GPCs([], {
        graphemes: this.graphemes,
        phonemes: this.phonemes
      });
      this.words = new Words([], {
        gpcs: this.gpcs
      });
      this.sentences = new Sentences([], {
        words: this.words
      });
      this.sequences = new Sequences([], {
        gpcs: this.gpcs,
        words: this.words,
        sentences: this.sentences
      });
    }

    Store.prototype.loadAll = function(callback) {
      var stack;
      stack = [this.phonemes, this.graphemes, this.gpcs, this.words, this.sentences, this.sequences];
      return this.loadStack(stack, callback);
    };

    Store.prototype.fetch = function(collection, callback) {
      var error, success;
      success = function(collection, response) {
        return callback();
      };
      error = function(collection, response) {
        return callback("TODO: meaningful error here");
      };
      return collection.fetch({
        success: success,
        error: error
      });
    };

    Store.prototype.loadStack = function(stack, callback) {
      var collection,
        _this = this;
      collection = stack.shift();
      return this.fetch(collection, function(error) {
        if (error != null) {
          return callback(error);
        } else if (stack.length === 0) {
          return callback();
        } else {
          return _this.loadStack(stack, callback);
        }
      });
    };

    return Store;

  })();

  GPC = (function(_super) {

    __extends(GPC, _super);

    GPC.name = 'GPC';

    function GPC(attributes, options) {
      GPC.__super__.constructor.call(this, attributes, options);
    }

    GPC.prototype.graphemeName = function() {
      var grapheme;
      grapheme = this.get('grapheme');
      if (grapheme != null) {
        return grapheme.get('name');
      } else {
        return null;
      }
    };

    GPC.prototype.parse = function(data) {
      this.parseIdLookup('graphemes', 'grapheme', data);
      this.parseIdLookup('phonemes', 'phoneme', data);
      return data;
    };

    return GPC;

  })(NamedModel);

  GPCs = (function(_super) {

    __extends(GPCs, _super);

    GPCs.name = 'GPCs';

    GPCs.prototype.model = GPC;

    GPCs.prototype.url = '/api/v1/gpcs/';

    function GPCs(models, options) {
      if (options == null) {
        options = {};
      }
      this.graphemes = options.graphemes;
      this.phonemes = options.phonemes;
      GPCs.__super__.constructor.call(this, models, options);
    }

    return GPCs;

  })(NamedCollection);

  GPCState = (function(_super) {

    __extends(GPCState, _super);

    GPCState.name = 'GPCState';

    function GPCState() {
      return GPCState.__super__.constructor.apply(this, arguments);
    }

    GPCState.prototype.defaults = {
      active: false,
      focus: false,
      gpc: null
    };

    GPCState.prototype.toggle = function() {
      if (!(this.get('active')) && !(this.get('focus'))) {
        return this.set({
          active: true
        });
      } else if ((this.get('active')) && !(this.get('focus'))) {
        return this.set({
          focus: true
        });
      } else {
        return this.set({
          active: false,
          focus: false
        });
      }
    };

    return GPCState;

  })(Backbone.Model);

  GPCStates = (function(_super) {

    __extends(GPCStates, _super);

    GPCStates.name = 'GPCStates';

    GPCStates.prototype.model = GPCState;

    function GPCStates(gpcs, options) {
      var models;
      if (gpcs instanceof GPCs) {
        gpcs = gpcs.models;
      }
      models = _.map(gpcs, function(gpc) {
        return new GPCState({
          gpc: gpc
        });
      });
      GPCStates.__super__.constructor.call(this, models, options);
    }

    return GPCStates;

  })(Backbone.Collection);

  Grapheme = (function(_super) {

    __extends(Grapheme, _super);

    Grapheme.name = 'Grapheme';

    function Grapheme() {
      return Grapheme.__super__.constructor.apply(this, arguments);
    }

    return Grapheme;

  })(NamedModel);

  Graphemes = (function(_super) {

    __extends(Graphemes, _super);

    Graphemes.name = 'Graphemes';

    function Graphemes() {
      return Graphemes.__super__.constructor.apply(this, arguments);
    }

    Graphemes.prototype.model = Grapheme;

    Graphemes.prototype.url = '/api/v1/graphemes/';

    return Graphemes;

  })(NamedCollection);

  Phoneme = (function(_super) {

    __extends(Phoneme, _super);

    Phoneme.name = 'Phoneme';

    function Phoneme() {
      return Phoneme.__super__.constructor.apply(this, arguments);
    }

    return Phoneme;

  })(NamedModel);

  Phonemes = (function(_super) {

    __extends(Phonemes, _super);

    Phonemes.name = 'Phonemes';

    function Phonemes() {
      return Phonemes.__super__.constructor.apply(this, arguments);
    }

    Phonemes.prototype.model = Phoneme;

    Phonemes.prototype.url = '/api/v1/phonemes/';

    return Phonemes;

  })(NamedCollection);

  Segmenter = (function() {

    Segmenter.name = 'Segmenter';

    function Segmenter(words, gpcs) {
      this.words = words;
      this.gpcs = gpcs;
    }

    Segmenter.prototype.segment = function() {
      var gpcs,
        _this = this;
      gpcs = this.gpcs.sortBy(function(gpc) {
        return gpc.graphemeName().length;
      });
      gpcs = gpcs.reverse();
      return this.words.each(function(word) {
        var foundGpc, gpc, remaining, wordGpcs, _i, _len;
        remaining = (word.get('name')).toLowerCase();
        wordGpcs = [];
        while (remaining !== '') {
          foundGpc = null;
          for (_i = 0, _len = gpcs.length; _i < _len; _i++) {
            gpc = gpcs[_i];
            if ((remaining.indexOf(gpc.graphemeName())) === 0) {
              foundGpc = gpc;
              break;
            }
          }
          if (!foundGpc) {
            wordGpcs = null;
            break;
          }
          remaining = remaining.substring(gpc.graphemeName().length);
          wordGpcs.push(foundGpc);
        }
        if (!(word.set({
          gpcs: wordGpcs
        }))) {
          throw new Error("Invalid word!");
        }
      });
    };

    return Segmenter;

  })();

  Sentence = (function(_super) {

    __extends(Sentence, _super);

    Sentence.name = 'Sentence';

    function Sentence() {
      return Sentence.__super__.constructor.apply(this, arguments);
    }

    Sentence.prototype.parse = function(data) {
      this.parseIdLookup('words', 'words', data);
      return data;
    };

    return Sentence;

  })(NamedModel);

  Sentences = (function(_super) {

    __extends(Sentences, _super);

    Sentences.name = 'Sentences';

    Sentences.prototype.model = Sentence;

    Sentences.prototype.url = '/api/v1/sentences/';

    function Sentences(models, options) {
      if (options == null) {
        options = {};
      }
      this.words = options.words;
      Sentences.__super__.constructor.call(this, models, options);
    }

    return Sentences;

  })(NamedCollection);

  Sequence = (function(_super) {

    __extends(Sequence, _super);

    Sequence.name = 'Sequence';

    function Sequence() {
      return Sequence.__super__.constructor.apply(this, arguments);
    }

    Sequence.prototype.parse = function(data) {
      if (data.elements != null) {
        data.elements = new SequenceElements(data.elements, {
          parse: true,
          collection: this
        });
      }
      return data;
    };

    return Sequence;

  })(NamedModel);

  Sequences = (function(_super) {

    __extends(Sequences, _super);

    Sequences.name = 'Sequences';

    Sequences.prototype.model = Sequence;

    Sequences.prototype.url = '/api/v1/sequences/';

    function Sequences(models, options) {
      if (options == null) {
        options = {};
      }
      this.sentences = options.sentences;
      this.words = options.words;
      this.gpcs = options.gpcs;
      Sequences.__super__.constructor.call(this, models, options);
    }

    return Sequences;

  })(NamedCollection);

  SequenceElement = (function(_super) {

    __extends(SequenceElement, _super);

    SequenceElement.name = 'SequenceElement';

    function SequenceElement() {
      return SequenceElement.__super__.constructor.apply(this, arguments);
    }

    SequenceElement.prototype.parse = function(data) {
      this.parseIdLookup('gpcs', 'gpc', data);
      this.parseIdLookup('words', 'new_words', data);
      this.parseIdLookup('sentences', 'new_sentences', data);
      return data;
    };

    return SequenceElement;

  })(NamedModel);

  SequenceElements = (function(_super) {

    __extends(SequenceElements, _super);

    SequenceElements.name = 'SequenceElements';

    SequenceElements.prototype.model = SequenceElement;

    function SequenceElements(models, options) {
      var _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
      if (options == null) {
        options = {};
      }
      this.sentences = (_ref = options.collection) != null ? (_ref1 = _ref.collection) != null ? _ref1.sentences : void 0 : void 0;
      this.words = (_ref2 = options.collection) != null ? (_ref3 = _ref2.collection) != null ? _ref3.words : void 0 : void 0;
      this.gpcs = (_ref4 = options.collection) != null ? (_ref5 = _ref4.collection) != null ? _ref5.gpcs : void 0 : void 0;
      SequenceElements.__super__.constructor.call(this, models, options);
    }

    return SequenceElements;

  })(NamedCollection);

  hasUpperCase = function(str) {
    return str.toLowerCase() !== str;
  };

  WHITESPACE = /[\u0009\u000A\u000B\u000C\u000D\u0020\u0085\u00A0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u2028\u2029\u202F\u205F\u3000]+/;

  DEBRIS = new XRegExp("[\\p{P}\\p{Sm}\\p{Sc}\\p{So}\\p{N}]", "g");

  HYPHEN_APOSTROPHE = "'`-\u2018\u2019\u2010";

  Wordlist = (function(_super) {

    __extends(Wordlist, _super);

    Wordlist.name = 'Wordlist';

    function Wordlist() {
      return Wordlist.__super__.constructor.apply(this, arguments);
    }

    Wordlist.prototype.url = '/api/v1/wordlist/1';

    Wordlist.prototype.defaults = {
      id: 1
    };

    Wordlist.prototype.initialize = function() {};

    Wordlist.prototype.toList = function() {
      var words;
      words = (this.get('wordlist')).split(WHITESPACE);
      words = _.unique(words);
      return _.reject(words, function(word) {
        return word === '';
      });
    };

    Wordlist.prototype.clean = function() {
      return this.fromArray(this.toList().sort());
    };

    Wordlist.prototype.fromArray = function(ary) {
      return this.set({
        wordlist: ary.join('\n')
      });
    };

    Wordlist.prototype.cleanUpperCase = function() {
      var list;
      list = this.toList();
      list = _.reject(list, function(word) {
        return hasUpperCase(word) && _.include(list, word.toLowerCase());
      });
      return this.fromArray(list);
    };

    Wordlist.prototype.cleanDebris = function() {
      var wordlist;
      wordlist = XRegExp.replace(this.get('wordlist'), DEBRIS, function(match) {
        if (HYPHEN_APOSTROPHE.indexOf(match[0]) >= 0) {
          return match[0];
        } else {
          return '';
        }
      });
      this.set({
        wordlist: wordlist
      });
      return this.clean();
    };

    Wordlist.prototype.resetWords = function(words) {
      var list;
      list = _.map(this.toList(), function(word) {
        return {
          name: word
        };
      });
      return words.reset(list);
    };

    return Wordlist;

  })(Backbone.Model);

  Word = (function(_super) {

    __extends(Word, _super);

    Word.name = 'Word';

    function Word() {
      return Word.__super__.constructor.apply(this, arguments);
    }

    Word.prototype.parse = function(data) {
      this.parseIdLookup('gpcs', 'gpcs', data);
      return data;
    };

    return Word;

  })(NamedModel);

  Words = (function(_super) {

    __extends(Words, _super);

    Words.name = 'Words';

    Words.prototype.url = '/api/v1/words/';

    Words.prototype.model = Word;

    Words.prototype.comparator = function(word) {
      return word.get('name');
    };

    function Words(models, options) {
      if (options == null) {
        options = {};
      }
      this.gpcs = options.gpcs;
      Words.__super__.constructor.call(this, models, options);
    }

    return Words;

  })(NamedCollection);

  if (window.DB != null) {
    describe("DB", function() {
      var gpcs, graphemes, phonemes, sentences, sequences, words;
      graphemes = new Graphemes(DB.graphemes, {
        parse: true
      });
      phonemes = new Phonemes(DB.phonemes, {
        parse: true
      });
      gpcs = new GPCs(DB.gpcs, {
        parse: true,
        graphemes: graphemes,
        phonemes: phonemes
      });
      words = new Words(DB.words, {
        parse: true,
        gpcs: gpcs
      });
      sentences = new Sentences(DB.sentences, {
        parse: true,
        words: words
      });
      sequences = new Sequences(DB.sequences, {
        parse: true,
        sentences: sentences,
        words: words,
        gpcs: gpcs
      });
      describe("graphemes", function() {
        return it("should load", function() {
          return (expect(graphemes.getByName('a'))).not.toBeNull();
        });
      });
      describe("phonemes", function() {
        return it("should load", function() {
          return (expect(phonemes.getByName('a'))).not.toBeNull();
        });
      });
      describe("GPCs", function() {
        it("should load", function() {
          return (expect(gpcs.getByName('a_a'))).not.toBeNull();
        });
        it("should associate grapheme id to graphemes", function() {
          var gpc, grapheme;
          gpc = gpcs.getByName('a_a');
          grapheme = gpc.get('grapheme');
          return (expect(grapheme instanceof Grapheme)).toBeTruthy();
        });
        return it("should associate phoneme id to phonemes", function() {
          var gpc, phoneme;
          gpc = gpcs.getByName('a_a');
          phoneme = gpc.get('phoneme');
          return (expect(phoneme instanceof Phoneme)).toBeTruthy();
        });
      });
      describe("words", function() {
        it("should load", function() {
          return (expect(words.getByName('ambao'))).not.toBeNull();
        });
        return it("should associate gpc ids to gpcs", function() {
          var ambao, ambaoGpcs, gpc;
          ambao = words.getByName('ambao');
          ambaoGpcs = ambao.get('gpcs');
          gpc = _.first(ambaoGpcs);
          return (expect(gpc.get('name'))).toEqual('a_a');
        });
      });
      describe("sentences", function() {
        it("should load", function() {
          return (expect(sentences.getByName('Warumi 16:24'))).not.toBeNull();
        });
        return it("should associate word ids to words", function() {
          var sentence, word;
          sentence = sentences.getByName('Warumi 16:24');
          word = _.first(sentence.get('words'));
          return (expect(word instanceof Word)).toBeTruthy();
        });
      });
      return describe("sequences", function() {
        var elements, sequence;
        sequence = null;
        elements = null;
        beforeEach(function() {
          sequence = sequences.getByName('Productivity Sequence');
          return elements = sequence.get('elements');
        });
        it("should load", function() {
          return (expect(sequence)).not.toBeNull();
        });
        it("should contain a collection of SequenceElements", function() {
          return (expect(elements instanceof SequenceElements)).toBeTruthy();
        });
        return describe("elements", function() {
          var element;
          element = null;
          beforeEach(function() {
            return element = elements.last();
          });
          it("should associate gpc ids to gpcs", function() {
            var gpc;
            gpc = element.get('gpc');
            return (expect(gpc instanceof GPC)).toBeTruthy();
          });
          it("should associate word ids to words", function() {
            var word;
            word = _.first(element.get('new_words'));
            return (expect(word instanceof Word)).toBeTruthy();
          });
          return it("should associate sentence ids to sentences", function() {
            var sentence;
            sentence = _.first(element.get('new_sentences'));
            return (expect(sentence instanceof Sentence)).toBeTruthy();
          });
        });
      });
    });
  }

  describe("GPC", function() {
    var gpc, graph, phone;
    gpc = null;
    graph = null;
    phone = null;
    beforeEach(function() {
      graph = new Grapheme({
        name: 'a'
      });
      phone = new Phoneme({
        name: 'b'
      });
      return gpc = new GPC({
        grapheme: graph,
        phoneme: phone
      });
    });
    return it("should have graphemeName to get grapheme name", function() {
      return (expect(gpc.graphemeName())).toEqual('a');
    });
  });

  describe("GPCs", function() {
    var gpc1, gpc2, gpc3, gpcs, _ref;
    gpcs = null;
    _ref = [null, null, null], gpc1 = _ref[0], gpc2 = _ref[1], gpc3 = _ref[2];
    beforeEach(function() {
      gpc1 = new GPC({
        name: 'a_a'
      });
      gpc2 = new GPC({
        name: 'b_b'
      });
      gpc3 = new GPC({
        name: 'c_c'
      });
      return gpcs = (new GPCs).reset([gpc1, gpc2, gpc3]);
    });
    return it("should exist", function() {
      return (expect(gpcs.length)).toEqual(3);
    });
  });

  describe("GPCState", function() {
    var state;
    state = null;
    beforeEach(function() {
      var gpc;
      gpc = new GPC({
        name: "a"
      });
      return state = new GPCState({
        gpc: gpc
      });
    });
    it("should make a gpc active but not focused when toggled", function() {
      state.toggle();
      (expect(state.get('active'))).toBeTruthy();
      return (expect(state.get('focus'))).toBeFalsy();
    });
    it("should make a gpc active and focused when toggled twice", function() {
      _.times(2, function() {
        return state.toggle();
      });
      (expect(state.get('active'))).toBeTruthy();
      return (expect(state.get('focus'))).toBeTruthy();
    });
    return it("should make a gpc neither active nor focused when toggled thrice", function() {
      _.times(3, function() {
        return state.toggle();
      });
      (expect(state.get('active'))).toBeFalsy();
      return (expect(state.get('focus'))).toBeFalsy();
    });
  });

  describe("GPCStates", function() {
    var states;
    states = null;
    return beforeEach(function() {
      var gpcs;
      gpcs = _.map(['a', 'b', 'c'], function(name) {
        return new GPC({
          name: name
        });
      });
      return states = new GPCStates(gpcs);
    });
  });

  describe("Grapheme", function() {
    var grapheme;
    grapheme = null;
    beforeEach(function() {
      return grapheme = new Grapheme;
    });
    return it("should exist", function() {
      return (expect(grapheme)).not.toBeNull();
    });
  });

  describe("Graphemes", function() {
    var graph1, graph2, graph3, graphs, _ref;
    graphs = null;
    _ref = [null, null, null], graph1 = _ref[0], graph2 = _ref[1], graph3 = _ref[2];
    beforeEach(function() {
      graph1 = new Grapheme({
        name: 'a'
      });
      graph2 = new Grapheme({
        name: 'b'
      });
      graph3 = new Grapheme({
        name: 'c'
      });
      return graphs = (new Graphemes).reset([graph1, graph2, graph3]);
    });
    return it("should exist", function() {
      return (expect(graphs.length)).toEqual(3);
    });
  });

  describe("NamedModel", function() {
    var model;
    model = null;
    beforeEach(function() {
      return model = new NamedModel;
    });
    it("should valid only with a name", function() {
      (expect(model.isValid())).not.toBeTruthy();
      model.set({
        name: "one"
      });
      return (expect(model.isValid())).toBeTruthy();
    });
    it("should not allow two models with the same name", function() {
      var coll, item1, item2;
      coll = new NamedCollection;
      item1 = new NamedModel({
        name: "one"
      });
      item2 = new NamedModel({
        name: "one"
      });
      coll.add(item1);
      coll.add(item2);
      return (expect(item2.isValid())).toBeFalsy();
    });
    return it("should allow setting attributes", function() {
      model.set({
        name: "one"
      });
      return (expect(model.set({
        something: ["two", "three", "four"]
      }))).toBeTruthy();
    });
  });

  describe("NamedCollection", function() {
    var collection, one, three, two, _ref;
    collection = null;
    _ref = [null, null, null], one = _ref[0], two = _ref[1], three = _ref[2];
    beforeEach(function() {
      collection = new NamedCollection;
      one = new NamedModel({
        name: "one"
      });
      two = new NamedModel({
        name: "two"
      });
      three = new NamedModel({
        name: "three"
      });
      return collection.reset([one, two, three]);
    });
    it("should be able to quickly find a model by name", function() {
      return (expect(collection.getByName('one'))).toEqual(one);
    });
    it("should be valid in a collection", function() {
      return (expect(one.isValid())).toBeTruthy();
    });
    return it("should return undefined if a name is not in the collection", function() {
      return (expect(collection.getByName('random'))).toBeNull();
    });
  });

  describe("Phoneme", function() {
    var phoneme;
    phoneme = null;
    beforeEach(function() {
      return phoneme = new Phoneme;
    });
    return it("should exist", function() {
      return (expect(phoneme)).not.toBeNull();
    });
  });

  describe("Phonemes", function() {
    var phone1, phone2, phone3, phones, _ref;
    phones = null;
    _ref = [null, null, null], phone1 = _ref[0], phone2 = _ref[1], phone3 = _ref[2];
    beforeEach(function() {
      phone1 = new Phoneme({
        name: 'a'
      });
      phone2 = new Phoneme({
        name: 'b'
      });
      phone3 = new Phoneme({
        name: 'c'
      });
      return phones = (new Phonemes).reset([phone1, phone2, phone3]);
    });
    return it("should exist", function() {
      return (expect(phones.length)).toEqual(3);
    });
  });

  describe("Segmenter", function() {
    var gpca, gpcb, gpcbb, gpcc, gpcs, segmenter, words, _ref;
    segmenter = null;
    words = null;
    _ref = [null, null, null, null], gpca = _ref[0], gpcb = _ref[1], gpcbb = _ref[2], gpcc = _ref[3];
    gpcs = null;
    beforeEach(function() {
      words = (new Words).reset([
        new Word({
          name: 'abba'
        }), new Word({
          name: 'bac'
        }), new Word({
          name: 'cab'
        })
      ]);
      gpca = new GPC({
        grapheme: new Grapheme({
          name: 'a'
        }),
        phoneme: new Phoneme({
          name: 'a'
        })
      });
      gpcbb = new GPC({
        grapheme: new Grapheme({
          name: 'bb'
        }),
        phoneme: new Phoneme({
          name: 'b'
        })
      });
      gpcb = new GPC({
        grapheme: new Grapheme({
          name: 'b'
        }),
        phoneme: new Phoneme({
          name: 'b'
        })
      });
      gpcc = new GPC({
        grapheme: new Grapheme({
          name: 'c'
        }),
        phoneme: new Phoneme({
          name: 'c'
        })
      });
      gpcs = (new GPCs).reset([gpca, gpcb, gpcbb, gpcc]);
      return segmenter = new Segmenter(words, gpcs);
    });
    return it("should segment abba", function() {
      var abba;
      segmenter.segment();
      abba = words.getByName('abba');
      return (expect(abba.get('gpcs'))).toEqual([gpca, gpcbb, gpca]);
    });
  });

  describe("Sentence", function() {
    var sentence;
    sentence = null;
    beforeEach(function() {
      return sentence = new Sentence;
    });
    return it("should exist", function() {
      return (expect(sentence)).not.toBeNull();
    });
  });

  describe("Sentences", function() {
    var sentence1, sentence2, sentence3, sentences, _ref;
    sentences = null;
    _ref = [null, null, null], sentence1 = _ref[0], sentence2 = _ref[1], sentence3 = _ref[2];
    beforeEach(function() {
      sentence1 = new Sentence({
        name: 'a'
      });
      sentence2 = new Sentence({
        name: 'b'
      });
      sentence3 = new Sentence({
        name: 'c'
      });
      return sentences = new Sentences([sentence1, sentence2, sentence3]);
    });
    return it("should exist", function() {
      return (expect(sentences.length)).toEqual(3);
    });
  });

  describe("SequenceElement", function() {
    var element;
    element = null;
    beforeEach(function() {
      return element = new SequenceElement;
    });
    return it("should exist", function() {
      return (expect(element)).not.toBeNull();
    });
  });

  describe("SequenceElements", function() {
    var element1, element2, element3, elements, _ref;
    elements = null;
    _ref = [null, null, null], element1 = _ref[0], element2 = _ref[1], element3 = _ref[2];
    beforeEach(function() {
      element1 = new SequenceElement({
        name: 'a'
      });
      element2 = new SequenceElement({
        name: 'b'
      });
      element3 = new SequenceElement({
        name: 'c'
      });
      return elements = new SequenceElements([element1, element2, element3]);
    });
    return it("should exist", function() {
      return (expect(elements.length)).toEqual(3);
    });
  });

  describe("Sequence", function() {
    var sequence;
    sequence = null;
    beforeEach(function() {
      return sequence = new Sequence;
    });
    return it("should exist", function() {
      return (expect(sequence)).not.toBeNull();
    });
  });

  describe("Sequences", function() {
    var sequence1, sequence2, sequence3, sequences, _ref;
    sequences = null;
    _ref = [null, null, null], sequence1 = _ref[0], sequence2 = _ref[1], sequence3 = _ref[2];
    beforeEach(function() {
      sequence1 = new Sequence({
        name: 'a'
      });
      sequence2 = new Sequence({
        name: 'b'
      });
      sequence3 = new Sequence({
        name: 'c'
      });
      return sequences = new Sequences([sequence1, sequence2, sequence3]);
    });
    return it("should exist", function() {
      return (expect(sequences.length)).toEqual(3);
    });
  });

  describe("util", function() {
    return describe("hasUpperCase()", function() {
      it("should detect word initial uppercase", function() {
        return (expect(hasUpperCase("Bonus"))).toBeTruthy();
      });
      it("should not describe lowercase as uppercase", function() {
        return (expect(hasUpperCase("bonus"))).not.toBeTruthy();
      });
      return it("should detect word medial uppercase", function() {
        return (expect(hasUpperCase("boNus"))).toBeTruthy();
      });
    });
  });

  describe("Wordlist", function() {
    var wordlist;
    wordlist = null;
    beforeEach(function() {
      return wordlist = new Wordlist();
    });
    return describe("toList()", function() {
      it("should get a list of words", function() {
        wordlist.set({
          wordlist: "one two three"
        });
        return (expect(wordlist.toList())).toEqual(["one", "two", "three"]);
      });
      it("should not have duplicates", function() {
        wordlist.set({
          wordlist: "one two one three"
        });
        return (expect(wordlist.toList())).toEqual(["one", "two", "three"]);
      });
      it("should clean the word list when asked", function() {
        wordlist.set({
          wordlist: "one \ntwo\t one  \n\n  three\n\n\n"
        });
        wordlist.clean();
        return (expect(wordlist.get('wordlist'))).toEqual("one\nthree\ntwo");
      });
      it("should clean uppercase when asked", function() {
        wordlist.set({
          wordlist: "One three Two one thrEE"
        });
        wordlist.cleanUpperCase();
        return (expect(wordlist.get('wordlist'))).toEqual("three\nTwo\none");
      });
      it("should clean debris when asked", function() {
        wordlist.set({
          wordlist: "one. tw`o, three-four 1 2 3 & % $ f've"
        });
        wordlist.cleanDebris();
        return (expect(wordlist.get('wordlist'))).toEqual("f've\none\nthree-four\ntw`o");
      });
      return it("should be able to reset Words with a new set of Word objects", function() {
        var words;
        words = new Words;
        wordlist.set({
          wordlist: "one two three"
        });
        wordlist.resetWords(words);
        return (expect((words.where({
          name: "two"
        })).length)).toEqual(1);
      });
    });
  });

  describe("Word", function() {
    var word;
    word = null;
    beforeEach(function() {
      return word = new Word({
        name: "one"
      });
    });
    return it("should be valid", function() {
      return (expect(word.isValid())).toBeTruthy();
    });
  });

  describe("Words", function() {
    var one, three, two, words, _ref;
    words = null;
    _ref = [null, null, null], one = _ref[0], two = _ref[1], three = _ref[2];
    beforeEach(function() {
      words = new Words();
      one = new Word({
        name: "one"
      });
      two = new Word({
        name: "two"
      });
      three = new Word({
        name: "three"
      });
      return words.reset([one, two, three]);
    });
    it("should be sorted alphabetically", function() {
      return (expect(words.models)).toEqual([one, three, two]);
    });
    return it("should be valid in a collection", function() {
      return (expect(words.models[0].isValid())).toBeTruthy();
    });
  });

  describe("Words searching", function() {
    var gpcs, graphemes, phonemes, words;
    graphemes = new Graphemes(DB.graphemes, {
      parse: true
    });
    phonemes = new Phonemes(DB.phonemes, {
      parse: true
    });
    gpcs = new GPCs(DB.gpcs, {
      parse: true,
      graphemes: graphemes,
      phonemes: phonemes
    });
    words = new Words(DB.words, {
      parse: true,
      gpcs: gpcs
    });
    return it("should be able to find words with target GPCs", function() {});
  });

}).call(this);
